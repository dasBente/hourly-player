#!/bin/bash

# Path to the users .hourlyplayer directory, their hourlies and lists
readonly WORK_PATH="$HOME/.hourlyplayer"
readonly HOURLIES="$WORK_PATH/hourlies"
readonly LISTS="$WORK_PATH/lists"

# Path to config and other inportant files
readonly CONFIG="$WORK_PATH/config"
readonly CURRENT="$WORK_PATH/CURRENT_HOURLY"
readonly MUTE="$WORK_PATH/MUTE"
readonly LAST_UPDATE="$WORK_PATH/LAST_UPDATE"

# Plays the current hourly
play_curr_hourly() {
    # Get current hourly and current hour of the day
    local cur_hourly=`cat "$CURRENT"`
    local cur_hour=`date +%H`

    aplay "$HOURLIES/$cur_hourly/$cur_hour.wav"
}

# Returns a (sorted) list of all hourlies
list_hourlies() {
    ls -d "$HOURLIES"/*/ | sed s_"$HOURLIES/"__ | sed s_/__
}

# Returns a sorted list of available hourlies
hourlies_in_list() {
    if [ "$1" == "" ]; then
	cat "$CONFIG" | grep default | sed s/default=//
    elif [ "$1" == "all" ]; then
	list_hourlies
    elif [[ "$1" =~ ^- ]]; then # Remove hourlies in negative list from available ones
	list="${1:1}"
	echo "$(list_hourlies)" | sort - "$LISTS/$list" | uniq -u
    else 
	cat "$LISTS/$1"
    fi
}

# Sets hourly to the given argument (if it is a valid hourly)
set_hourly() {
    if [[ "$(list_hourlies)" =~ (^|[[:space:]])"$1"($|[[:space:]])  ]]; then
	echo "$(date +%m%d)" > "$LAST_UPDATE"
	echo "$1" > "$CURRENT"
	exit 0
    else
	echo "The given hourly is not known."
	exit 1
    fi
}

# Generate a new hourly from the list defined in config
new_hourly() {
    # Pick a new hourly # TODO: Probably rework this (maybe with cut)

    # Check which list of hourlies should be used
    local list="$(current_list)"

    hourlies=`hourlies_in_list "$list"`
    
    # Number of hourlies in the list
    local num_hourlies=`echo "$hourlies" | wc -w`

    # Choose a hourly at random
    local rand=`echo $((RANDOM % $num_hourlies + 1))`
    echo $hourlies | cut -d " " -f $rand > "$CURRENT"
}

update_hourly() {
    # Get data necessary to deduce whether hourlies are up to date
    local today=`date +%m%d`
    local last_update=""
    
    if [ -e "$LAST_UPDATE" ]; then
	last_update=`cat "$LAST_UPDATE"`
    fi

    # Update todays hourly if not up to date, otherwise we're done
    if [ "$today" != "$last_update" ]; then
	new_hourly
    fi

    # Update LAST_UPDATE
    echo $today > "$LAST_UPDATE"
}

# Display current hourly
current_hourly() {
    echo `cat "$CURRENT"`
}

# Pretty prints list of all available hourlies in the .hourlyplayer directory
pp_all_hourlies() {
    list_hourlies | column
}

# Lists all available hourly lists
all_lists() {
    ls "$LISTS"
}

# Display current default
current_default() {
    cat "$CONFIG" | grep default | cut -d'=' -f2
}

# Set the current default
set_default() {
    sed -i s/default=.*/default="$1"/ "$CONFIG"
}

# Print the currently selected list
current_list() {
    cat "$CONFIG" | grep hourly_list | sed s/hourly_list=// 
}

# Set the current list
set_list() {
    sed -i s/hourly_list=.*/hourly_list="$1"/ "$CONFIG"
}

# Print all hourlies that can currently be selected by the player
all_in_list() {
    hourlies_in_list "$(current_list)"
}

# Mute the hourly player
mute() {
    touch "$MUTE"
}

# Unmute the hourly player
unmute() {
    if [[ -e "$MUTE" ]]; then
	rm "$MUTE"
    fi
}

# Print usage help
usage() {
    echo "Usage: $0 [-haAcCldnmM|-L [NEW_LIST]|-D [NEW_DEFAULT]|-N [NEW_HOURLY]]" 1>&2
}

# Main function
main() {
    while getopts "hcCL:aAldD:nN:mM" opt; do
	case "$opt" in
	    h) usage ;;
	    c) current_hourly ;;
	    a) pp_all_hourlies ;;
	    A) all_in_list ;;
	    l) all_lists ;;
	    C) current_list ;;
	    L) set_list "$OPTARG" ;;
	    d) current_default ;;
	    D) set_default "$OPTARG" ;;
	    n) new_hourly ;;
	    N) set_hourly "$OPTARG" ;;
	    m) mute ;;
	    M) unmute ;;
	esac
	exit 0
    done

    # Check, whether the .hourlyplayer directory exists
    if [ ! -d "$WORK_PATH" ]; then
	mkdir "$WORK_PATH"
    fi
    
    # Check whether MUTE exists and update and play hourlies otherwise
    if [ ! -e "$MUTE" ]; then
	update_hourly
	play_curr_hourly
    fi
}

main "$@"
